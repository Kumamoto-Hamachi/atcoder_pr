制限時間が1秒の場合、
10の6乗　余裕を持って間に合う
10の7乗　おそらく間に合う
10の8乗　非常にシンプルな処理でない限り厳しい

10**5 の単純な dfs は pypy だと TLE

計算量を多めに見積もって間に合わなさそうなときは、きっと間に合う
明らかに間に合わない場合は間に合わない

log_2 10**5 = 17
log_2 10**6 = 20
log_2 10**7 = 23
log_2 10**8 = 26

 9! =    362,880
10! =  3,628,800 <- 間に合う
11! = 39,916,800

2**18 =   262,144
2**19 =   524,288
2**20 = 1,048,576

素数の数
100 まで 25
1000 まで 168
10**6 まで 78,498
10**9 まで 50,847,534


unsigned long long
18,446,744,073,709,551,615 : 10**20 くらい

# url

solved problems
https://kenkoooo.com/atcoder/#/table/NagatoAlice

rate and performace
https://atcoder-charts.netlify.app/#/

rate diff
https://atcoder-rating-comparison.herokuapp.com/?q=kikuchi0408%20NagatoAlice%20yokoMk2%20Kumamoto

# 解き方
**D以上は、挙動を確認する(サンプルが通ることだけでは不十分)**

まず全探索
音読(条件・sample tips も込み)
分割統治法、動的計画法、答え2分探索、累積和(片側固定の結果があるときに効率的に解けるか)
逆を考える
方向を揃えたら、後処理でまとめてできることがある
数式の片側に、一度でアクセスできるものをまとめる
全探索、一部だけ全探索
前からも後ろからも考える
元の状態に戻る操作を考える
端っこのケースを考えて、隣のケースを考える
包除原理

小さな(簡単な)問題を考える
複数の別の問題に分ける。
見方を変える。given から解くのか、answer から解くのか

ダイクストラ法は、辺の数を減らす、visited は配列で
木は、f(頂点A,B) ではなく、f(根, 頂点A) に変換
和はビットごとでも計算できる

黒と白を並べる組み合わせは、座標の経路問題に落とせる
グラフに落とす問題は、辺に落とすか、点に落とすか、両方考える

ゲーム遷移で、負け状態は勝ちを伝播。勝ち状態は次数ライフを減らす

f"{hoge} {fuga}" は使えない。format() を使うこと

# RE, WA
コーナーケース
簡単な問題を作成(たまたま答えが一緒のこともあるので、挙動を確認する)
小数誤差
best を取得する while true: は new と best が同値でも continue (整数で更新されてなくても極値とは限らない)
音読(条件・sample tips も込み)
最初から書く

グラフなら、multi edge、self edge, cost 0 edge があるか

A* は pop で最小値を保証できるので、visited はT/F配列でOK


# TLE
計算量
recursion
pypy, python
配列の再利用


